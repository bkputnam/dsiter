package dsiter.row;

public class ParserMutator {

	protected int index;

	public static IParserMutator getInstance(ColumnType type, int index) {
		ParserMutator base = new ParserMutator(index);

		switch (type) {
			<% ColumnTypes.each { type -> %>
			case ${type.type}: return base.new ${type.type}();<% } %>

			default:
				throw new IllegalArgumentException("Unsupported ColumnType: " + type);
		}
	}

	private ParserMutator(int index) {
		this.index = index;
	}

	<%
		def parserFns = [
			"int": "Integer.parseInt",
			"long": "Long.parseLong",
			"float": "Float.parseFloat",
			"double": "Double.parseDouble",
			"boolean": "Boolean.parseBoolean",
			"String": ""
		]
		ColumnTypes.each { type ->
			def parserFn = parserFns[type.nativeType]
	%>
	protected class ${type.type} implements IParserMutator {
		@Override
		public void parseAndMutate(String value, Row row) {
			row.${type.rowArray}[index] = ${parserFn}(value);
		}
	}
	<% } %>
}
