package dsiter.row;

/**
 * Interface for classes that parse strings and insert them directly into
 * Rows.
 *
 * <p>
 *     You probably won't have to implement this interface yourself: it
 *     comes with default implementations for all the standard types
 *     (e.g. uses {@code Integer.parseInt} for ints, {@code Boolean.parseBoolean}
 *     for booleans, etc. The only reason to make a custom implementation
 *     is if you want to parse values in some other format.
 * </p>
 */
public interface IParserMutator {

    /**
     * Parse a string value and insert it into the passed Row
     *
     * @param value The string value to be parsed
     * @param row   The Row to be modified
     */
    void parseAndMutate(String value, Row row);

    /**
     * Given a ColumnType and an index, return an {@code IParserMutator}
     * instance that parses that type and inserts it into Rows at the
     * specified index.
     *
     * @param type  The type to be parsed
     * @param index The location at which the parsed values should be
     *              inserted
     * @return An {@code IParserMutator} instance that parses
     * {@code type} values and inserts them at {@code index}
     */
    static IParserMutator getInstance(ColumnType type, int index) {
        switch (type) {
            <%
                def parsers = [
                    "INT": "Integer.parseInt",
                    "LONG": "Long.parseLong",
                    "FLOAT": "Float.parseFloat",
                    "DOUBLE": "Double.parseDouble",
                    "STRING": "",
                    "BOOLEAN": "Boolean.parseBoolean"
                ];
                ColumnTypes.each { type ->
                    parser = parsers[type.type]
            %>
            case ${type.type}: return new IParserMutator() {
                @Override
                public void parseAndMutate(String value, Row row) {
                    row.${type.rowArray}[index] = ${parser}(value);
                }
            };
            <% } %>
            default:
                throw new Error("Programmer Error: this should be impossible");
        }
    }
}
