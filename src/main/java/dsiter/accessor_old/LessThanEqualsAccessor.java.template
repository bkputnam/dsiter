package dsiter.accessor_old;

import dsiter.row.ColumnType;
import dsiter.row.IRowAccessor;
import dsiter.row.IRowAccessor;

/**
 * Binary operator that tests whether {@code lhs} is less than or equal
 * to {@code rhs}
 *
 * <p>
 *     You probably won't ever want to use this class directly;
 *     it's much simpler to use {@link dsiter.parser.OperatorParser}
 *     directly. However, I certainly won't tell you you can't!
 * </p>
 */
public class LessThanEqualsAccessor extends TypedBinaryAccessor {

	public LessThanEqualsAccessor(IRowAccessor lhs, IRowAccessor rhs) {
		super(lhs, rhs);
	}

	@Override
	public ColumnType getReturnType(ColumnType lhsType, ColumnType rhsType) {
		return ColumnType.BOOLEAN;
	}

	@Override
	protected boolean testTypeCompatibility(ColumnType lhsType, ColumnType rhsType) {
		return (lhsType.isNumeric() && rhsType.isNumeric()) ||
		    (lhsType == ColumnType.JSDATE && rhsType == ColumnType.JSDATE) ||
		    (eitherTypeIs(ColumnType.JSDATE) && (eitherTypeIs(ColumnType.INT) || eitherTypeIs(ColumnType.LONG)));
	}

	@Override
	protected boolean handle_int_jsdate_bool(int lhs, long rhs) { return lhs <= rhs; }
	@Override
	protected boolean handle_long_jsdate_bool(long lhs, long rhs) { return lhs <= rhs; }
	@Override
	protected boolean handle_jsdate_int_bool(long lhs, int rhs) { return lhs <= rhs; }
	@Override
	protected boolean handle_jsdate_long_bool(long lhs, long rhs) { return lhs <= rhs; }
	@Override
	protected boolean handle_jsdate_jsdate_bool(long lhs, long rhs) { return lhs <= rhs; }

	<%
		def numberTypes = ["int", "long", "float", "double"]
		numberTypes.each { lhsType ->
			numberTypes.each { rhsType ->
	%>
	@Override
	protected boolean handle_${lhsType}_${rhsType}_bool(${lhsType} lhs, ${rhsType} rhs) { return lhs <= rhs; }
	<% }} %>
}
