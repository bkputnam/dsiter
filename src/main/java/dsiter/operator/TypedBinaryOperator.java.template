package dsiter.operator;

import dsiter.row.ColumnType;
import dsiter.row.IRowAccessor;
import dsiter.row.Row;
import dsiter.row.TypedRowAccessor;

/**
 * Abstract class for use in creating binary operators. Not all binary operators
 * need to use this class, but it's almost certainly easier to implement if you
 * do.
 * 
 * <p>
 * 		Subclasses must override the {@link #getReturnType} and {@link #testTypeCompatibility}
 *		methods. This class can then use that information to determine how best to process
 *		the child operators.
 * </p>
 *
 * <p>
 * 		This class provides overrideable methods for every possible type combination
 *		of {@code lhs}, {@code rhs}, and {@code returnValue} (which means there are
 *		{@code (# of types)^3} overridable methods available). Subclasses only
 *		need to override the methods which they will actually support. So, for example,
 *		a logical boolean operator only needs to override {@link #handle_boolean_boolean_boolean}
 *		and a numeric operator will only need to override the appropriate numeric
 *		{@code handle_x_y_z} methods. This superclass will use the information from
 *		{@link #getReturnType} and {@link #testTypeCompatibility} to efficiently determine
 *		which method to call.
 * </p>
 * 
 * @see TypedUnaryOperator
 */
public abstract class TypedBinaryOperator extends TypedRowAccessor {

	/**
	 * Left Hand Side
	 */
	private TypedRowAccessor lhs;

	/**
	 * Right Hand Side
	 */
	private TypedRowAccessor rhs;

	/**
	 * Construct a TypedBinaryOperator with {@code lhs} and {@code rhs} as
	 * its left- and right-hand sides, respectively.
	 * 
	 * @param lhs	The {@code TypedRowAccessor} that will provide the left
	 *				hand side of the operation
	 * @param rhs	The {@code TypedRowAccessor} that will provide the right
	 *				hand side of the operation
	 */
	public TypedBinaryOperator(TypedRowAccessor lhs, TypedRowAccessor rhs) {
		this.lhs = lhs;
		this.rhs = rhs;

		if(lhs == null) { throw new IllegalArgumentException("lhs cannot be null"); }
		if(rhs == null) { throw new IllegalArgumentException("rhs cannot be null"); }

		ColumnType lhsType = lhs.getType();
		ColumnType rhsType = rhs.getType();

        if(!testTypeCompatibility(lhsType, rhsType)) {
            throw new IllegalArgumentException("Incompatible types: " + lhsType + ", " + rhsType);
        }

		ColumnType returnType = super.type = this.getReturnType(lhsType, rhsType);
		super.innerAccessor = getInnerAccessor(lhs, rhs, returnType);
	}

	/**
	 * Subclasses must implement this method to let the superclass know the return type
	 * of this operation. This method will only be called if {@link #testTypeCompatibility}
	 * returned {@code true}.
	 * 
	 * @param lhsType	The type of the left hand side of the operator
	 * @param rhsType	The type of the right hand side of the operator
	 * @return	The return type of the operation
	 */
	protected abstract ColumnType getReturnType(ColumnType lhsType, ColumnType rhsType);

	/**
	 * Subclasses must implement this method to let the superclass know whether or not they
	 * will accept {@code lhsType} and {@code rhsType} as valid argument types or not.
	 * 
	 * @param lhsType	The type of the left hand side of the operator
	 * @param rhsType	The type of the right hand side of the operator
	 * @return	{@code true} if the subclass will accept the passed types, else {@code false}
	 */
	protected abstract boolean testTypeCompatibility(ColumnType lhsType, ColumnType rhsType);

	/**
	 * Utility method for subclasses, shorthand for {@code lhs.getType() == type || rhs.getType() == type}
	 * 
	 * @param type The type to be tested
	 * @return {@code true} if either {@code lhs} or {@code rhs} has type {@code type}, else {@code false}
	 */
    protected boolean eitherTypeIs(ColumnType type) { return lhs.getType() == type || rhs.getType() == type; }

	/**
	 * Utility method for subclasses, shorthand for {@code lhs.getType() == type && rhs.getType() == type}
	 * 
	 * @param type The type to be tested
	 * @return {@code true} if both {@code lhs} and {@code rhs} have type {@code type}, else {@code false}
	 */
    protected boolean bothTypesAre(ColumnType type) { return lhs.getType() == type && rhs.getType() == type; }

<%
def typeSwitch(indent, varName, bodyGenerator) {
	ColumnTypes.eachWithIndex { type, index ->
//		println ""
		if(index == 0) { print "${indent}if" } else { print "\n${indent}else if" }
		println "(" + varName + " == ColumnType." + type.type + ") {"
		bodyGenerator(indent + "\t", type)
		print "\n" + indent + "}"
	}
	println "\n" + indent + "else {"
	println indent + "\tthrow new Error(\"This should be impossible\");"
	print indent + "}"
}
%>

	private IRowAccessor getInnerAccessor(TypedRowAccessor lhs, TypedRowAccessor rhs, ColumnType returnType) {
		ColumnType lhsType = lhs.getType();
		ColumnType rhsType = rhs.getType();

<%
	typeSwitch("\t\t", "lhsType") { indent1, lhsType ->
		typeSwitch(indent1, "rhsType") { indent2, rhsType ->
			typeSwitch(indent2, "returnType") { indent3, returnType ->
				def methodName = "handle_" + lhsType.nativeType + "_" + rhsType.nativeType + "_" + returnType.nativeType;
				print "${indent3}return new ${lhsType.type}_${rhsType.type}_${returnType.type}(lhs, rhs);"
			}
		}
	}
%>
	}

	<%
		ColumnTypes.each { lhsType -> ColumnTypes.each { rhsType -> ColumnTypes.each { returnType ->
		def methodName = "handle_" + lhsType.nativeType + "_" + rhsType.nativeType + "_" + returnType.nativeType;
	%>
	/**
	 * Overrideable method. Computes value of operation from typed left- and right-hand side variables.
	 * 
	 * @param lhs The value of the left-hand side
	 * @param rhs The value of the right-hand side
	 * @return The computed value of the binary operator
	 */
	protected ${returnType.nativeType} ${methodName}( ${lhsType.nativeType} lhs, ${rhsType.nativeType} rhs )  { throw new Error("Programmer error: ${methodName} must be overridden by subclass"); }<% }}} %>

<%
ColumnTypes.each { lhsType ->
	ColumnTypes.each { rhsType ->
		ColumnTypes.each { returnType ->
			def methodName = "handle_" + lhsType.nativeType + "_" + rhsType.nativeType + "_" + returnType.nativeType;
%>
	private class ${lhsType.type}_${rhsType.type}_${returnType.type} extends TypedRowAccessor.${returnType.type} {

		private TypedRowAccessor.${lhsType.type} lhs;
		private TypedRowAccessor.${rhsType.type} rhs;

		private ${lhsType.type}_${rhsType.type}_${returnType.type}(TypedRowAccessor lhs, TypedRowAccessor rhs) {
			this.lhs = lhs.as${lhsType.capitalized}Accessor();
			this.rhs = rhs.as${rhsType.capitalized}Accessor();
		}

		public ${returnType.nativeType} get${returnType.capitalized}FromRow(Row row) {
			return ${methodName}(lhs.get${lhsType.capitalized}FromRow(row), rhs.get${rhsType.capitalized}FromRow(row));
		}
	}
<% }}} %>
}